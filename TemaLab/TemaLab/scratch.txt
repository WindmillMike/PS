import numpy as np
import matplotlib.pyplot as plt
from scipy.datasets import ascent # nu imi gasea modulul misc
from scipy.fft import dctn, idctn
from tabele_huffman import HUFFMAN_DC_LUMINANCE, HUFFMAN_AC_LUMINANCE

X = ascent()

Q_jpeg = np.array([
    [16, 11, 10, 16, 24, 40, 51, 61],
    [12, 12, 14, 19, 26, 28, 60, 55],
    [14, 13, 16, 24, 40, 57, 69, 56],
    [14, 17, 22, 29, 51, 87, 80, 62],
    [18, 22, 37, 56, 68, 109,103, 77],
    [24, 35, 55, 64, 81, 104,113, 92],
    [49, 64, 78, 87, 103,121,120,101],
    [72, 92, 95, 98, 112,100,103, 99]
], dtype=float)


def adaugarePadding(X2):
    inaltime, latime = X2.shape
    n, m = (-latime) % 8, (-inaltime) % 8
    ceva = np.zeros((inaltime + m, latime + n), dtype=X2.dtype)
    ceva[:inaltime, :latime] = X2
    return ceva

def spirala(bloc):
    l = 0
    vector = np.zeros(64)
    for i in range(14):
        if i < 8:
            for j in range(i + 1):
                if i % 2 == 0:
                    vector[l] = bloc[i - j][j]
                elif i % 2:
                    vector[l] = bloc[j][i - j]
                l += 1
        else:
            for j in range(8 - (i % 7)):
                if i % 2 == 0:
                    vector[l] = bloc[7 - j][j + i % 7]
                elif i % 2:
                    vector[l] = bloc[j + i % 7][7 - j]
                l += 1
    vector[l] = bloc[7][7]
    return np.array(vector)

def binar_size(x):
    if x == 0:
        return 0
    size = int(np.floor(np.log2(np.abs(x)))) + 1
    if size > 10:
        return 10
    return size

def binar_ac(x, size):
    if x == 0:
        return ""
    x = int(x)
    if x > 0:
        return format(x, f"0{size}b")
    else:
        x2 = (1 << size) - 1 + x
        return format(x2, f"0{size}b")

def huffman_codare(ac, huffman):
    contor = 0
    for i in range(63):
        v = ac[i]
        if v == 0:
            contor += 1
            if contor == 16:
                huffman[-1].append(("AC" + str(i), 0xF0))
                contor = 0
        else:
            ac_binar = binar_size(v)
            ac_codat = (contor << 4) | ac_binar
            huffman[-1].append(("AC" + str(i), ac_codat, v))  # ac_codat ne spune ca nr de zero e partea intreaga din ac_codat // 16 si restul rep numarul de biti necesari pentru a rep nr v de ex. 33 ne spune 33 // 16 e 2 (2 zero-uri) si deci 1 bit ramas ca sa se rep nr v
            contor = 0

    if contor > 0:
        huffman[-1].append(("AC" + str(i), 0x00))


def transformare_octeti(x):
    padding_len = (8 - (len(x) % 8)) % 8
    x += "0" * padding_len

    v = []
    for i in range(0, len(x), 8):
        octet = x[i:i + 8]
        valoare = int(octet, 2)
        v.append(hex(valoare))

        if valoare == 0xFF:
            v.append('0x00')

    return v



inaltime, latime = X.shape
X2 = X.copy().astype(float)
X2 = adaugarePadding(X2)
inaltime2, latime2 = X2.shape
reconstruit = np.zeros_like(X2, dtype=float)

dc_anterior = 0.0
huffman = []


for i in range(inaltime2 // 8):
    for j in range(latime2 // 8):
        x = X2[i * 8:(i + 1) * 8, j * 8:(j + 1) * 8]
        y = dctn(x).astype(float)
        y_impartit = np.round(y / Q_jpeg)

        spirala1 = spirala(y_impartit) # aici facem zig-zagul pentru ca 0-urile sa fie grupate frumos

        dc_actual = spirala1[0] - dc_anterior  # se realizeaza pentru o codare huffman mai buna si pentru ca diferenta de luminozitate intre blocuri e mica
        size = binar_size(dc_actual)
        dc_anterior = spirala1[0]
        ac = spirala1[1:]
        huffman.append([])
        huffman[-1].append(("DC", size, dc_actual))
        huffman_codare(ac, huffman)

        y_inmultit = Q_jpeg * y_impartit
        x_jpeg = idctn(y_inmultit)
        reconstruit[i * 8:(i + 1) * 8, j * 8:(j + 1) * 8] = x_jpeg

bitstream = ""
for bloc in huffman:
    for pixel in bloc:
        if pixel[0] == "DC":
            size = pixel[1]
            dc_actual = pixel[2]
            size_codat = HUFFMAN_DC_LUMINANCE.get(size)
            dc_binar = binar_ac(dc_actual, size)
            bitstream += size_codat + dc_binar

        elif len(pixel) == 2:
            bitstream += HUFFMAN_AC_LUMINANCE.get(pixel[1])
        elif len(pixel) == 3:
            size_cu_zero = pixel[1]
            valoare = pixel[2]
            size = size_cu_zero & 0x0F
            size_cu_zero_codat = HUFFMAN_AC_LUMINANCE.get(size_cu_zero)
            valoare_binar = binar_ac(valoare, size)
            bitstream += size_cu_zero_codat + valoare_binar


payload_jpeg = transformare_octeti(bitstream)
print(payload_jpeg)




x5 = binar_ac(33, 6)
print(x5)
print(transformare_octeti(x5))
reconstruit2 = reconstruit[:inaltime, :latime]
reconstruit3 = np.clip(reconstruit, 0, 255).astype(np.uint8)



